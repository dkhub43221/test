local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Express Hub | Premium Arsenal Script",
   LoadingTitle = "Express Hub",
   LoadingSubtitle = "by They_fwdan",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "paidarsenalscript"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided",
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})




            

Rayfield:Notify({
    Title = "Executed",
    Content = "You successfully executed the script!",
    Duration = 6.5,
    Image = 4483362458,
    Actions = { -- Notification Buttons
        Ignore = {
            Name = "Okay!",
            Callback = function()
                print("The user tapped Okay!")
            end
        },
    },
})







local Tab = Window:CreateTab("Main", 4483362458) -- Title, Image





local hitboxEnabled = false
local noCollisionEnabled = false
local hitbox_original_properties = {}
local hitboxSize = 21
local hitboxTransparency = 6
local teamCheck = "FFA" 

local defaultBodyParts = {
    "UpperTorso",
    "Head",
    "HumanoidRootPart"
}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- -------------------------------------
-- Utility Functions
-- -------------------------------------
local function savedPart(player, part)
    if not hitbox_original_properties[player] then
        hitbox_original_properties[player] = {}
    end
    if not hitbox_original_properties[player][part.Name] then
        hitbox_original_properties[player][part.Name] = {
            CanCollide = part.CanCollide,
            Transparency = part.Transparency,
            Size = part.Size
        }
    end
end

local function restoredPart(player)
    if hitbox_original_properties[player] then
        for partName, properties in pairs(hitbox_original_properties[player]) do
            local part = player.Character and player.Character:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = properties.CanCollide
                part.Transparency = properties.Transparency
                part.Size = properties.Size
            end
        end
    end
end

local function findClosestPart(player, partName)
    if not player.Character then return nil end
    local characterParts = player.Character:GetChildren()
    for _, part in ipairs(characterParts) do
        if part:IsA("BasePart") and part.Name:lower():match(partName:lower()) then
            return part
        end
    end
    return nil
end

-- -------------------------------------
-- Hitbox Functions
-- -------------------------------------
local function extendHitbox(player)
    for _, partName in ipairs(defaultBodyParts) do
        local part = player.Character and (player.Character:FindFirstChild(partName) or findClosestPart(player, partName))
        if part and part:IsA("BasePart") then
            savedPart(player, part)
            part.CanCollide = not noCollisionEnabled
            part.Transparency = hitboxTransparency / 10
            part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
        end
    end
end

local function isEnemy(player)
    if teamCheck == "FFA" or teamCheck == "Everyone" then
        return true
    end
    local localPlayerTeam = LocalPlayer.Team
    return player.Team ~= localPlayerTeam
end

local function shouldExtendHitbox(player)
    return isEnemy(player)
end

local function updateHitboxes()
    for _, v in ipairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            if shouldExtendHitbox(v) then
                extendHitbox(v)
            else
                restoredPart(v)
            end
        end
    end
end

-- -------------------------------------
-- Event Handlers
-- -------------------------------------
local function onCharacterAdded(character)
    task.wait(0.1)
    if hitboxEnabled then
        updateHitboxes()
    end
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(onCharacterAdded)
    player.CharacterRemoving:Connect(function()
        restoredPart(player)
        hitbox_original_properties[player] = nil
    end)
end

local function checkForDeadPlayers()
    for player, properties in pairs(hitbox_original_properties) do
        if not player.Parent or not player.Character or not player.Character:IsDescendantOf(game) then
            restoredPart(player)
            hitbox_original_properties[player] = nil
        end
    end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end

-- Rayfield UI Integration
HitboxSection = Tab:CreateSection("Hitbox Settings")

Toggle = Tab:CreateToggle({
    Name = "Enable Hitbox Expander",
    CurrentValue = false,
    Callback = function(enabled)
        hitboxEnabled = enabled
        if not enabled then
            for _, player in ipairs(Players:GetPlayers()) do
                restoredPart(player)
            end
            hitbox_original_properties = {}
        else
            updateHitboxes()
            coroutine.wrap(function()
                while hitboxEnabled do
                    updateHitboxes()
                    checkForDeadPlayers()
                    task.wait(0.1)
                end
            end)()
        end
    end,
})

Slider = Tab:CreateSlider({
    Name = "Hitbox Size",
    Range = {1, 25},
    Increment = 1,
    Suffix = "Units",
    CurrentValue = hitboxSize,
    Callback = function(value)
        hitboxSize = value
        if hitboxEnabled then
            updateHitboxes()
        end
    end,
})

Slider = Tab:CreateSlider({
    Name = "Hitbox Transparency",
    Range = {1, 10},
    Increment = 1,
    Suffix = "Transparency",
    CurrentValue = hitboxTransparency,
    Callback = function(value)
        hitboxTransparency = value
        if hitboxEnabled then
            updateHitboxes()
        end
    end,
})


Toggle = Tab:CreateToggle({
    Name = "No Collision",
    CurrentValue = false,
    Callback = function(enabled)
        noCollisionEnabled = enabled
        if hitboxEnabled then
            updateHitboxes()
        end
    end,
})













Section = Tab:CreateSection("Instant Kill",false) -- The 2nd argument is to tell if its only a Title and doesnt contain element


-- Assuming 'Tab' is already defined and set up correctly
local Toggle = Tab:CreateToggle({
    Name = "Instant kill", -- Use Name for Rayfield
    CurrentValue = false, -- Initial value for the toggle
    Flag = nil, -- Unique identifier for the toggle
    Callback = function(Value)
        getgenv().AutoFarm = Value

        local runServiceConnection
        local mouseDown = false
        local player = game.Players.LocalPlayer
        local camera = game.Workspace.CurrentCamera

        -- Set the current curse based on the toggle state
        game:GetService("ReplicatedStorage").wkspc.CurrentCurse.Value = Value and "Infinite Ammo" or ""

        local function getClosestEnemyPlayer()
            local closestDistance = math.huge
            local closestPlayer = nil

            for _, enemyPlayer in pairs(game.Players:GetPlayers()) do
                if enemyPlayer ~= player and enemyPlayer.TeamColor ~= player.TeamColor and enemyPlayer.Character then
                    local character = enemyPlayer.Character
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    local humanoid = character:FindFirstChild("Humanoid")
                    if humanoidRootPart and humanoid and humanoid.Health > 0 then
                        local distance = (player.Character.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                        if distance < closestDistance and humanoidRootPart.Position.Y >= 0 then
                            closestDistance = distance
                            closestPlayer = enemyPlayer
                        end
                    end
                end
            end

            return closestPlayer
        end

        local function startAutoFarm()
            -- Ensure TimeScale is set appropriately when starting
            game:GetService("ReplicatedStorage").wkspc.TimeScale.Value = 12

            runServiceConnection = game:GetService("RunService").Stepped:Connect(function()
                if getgenv().AutoFarm then
                    local closestPlayer = getClosestEnemyPlayer()
                    if closestPlayer then
                        local targetPosition = closestPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 0, -4)
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
                            camera.CFrame = CFrame.new(camera.CFrame.Position, closestPlayer.Character.Head.Position)

                            if not mouseDown then
                                mouse1press()  -- This simulates the left mouse button being pressed
                                mouseDown = true
                            end
                        end
                    else
                        if mouseDown then
                            mouse1release()  -- This simulates releasing the left mouse button
                            mouseDown = false
                        end
                    end
                else
                    -- If AutoFarm is turned off, clean up connections and reset state
                    if runServiceConnection then
                        runServiceConnection:Disconnect()
                        runServiceConnection = nil
                    end
                    if mouseDown then
                        mouse1release()
                        mouseDown = false
                    end
                end
            end)
        end

        local function onCharacterAdded(character)
            wait(0.5)
            if getgenv().AutoFarm then
                startAutoFarm()  -- Start AutoFarm if it's enabled upon character addition
            end
        end

        player.CharacterAdded:Connect(onCharacterAdded)

        -- Start or stop AutoFarm based on the toggle state
        if Value then
            wait(0.5)
            startAutoFarm()  -- Start AutoFarm if toggle is on
        else
            game:GetService("ReplicatedStorage").wkspc.CurrentCurse.Value = ""
            getgenv().AutoFarm = false
            game:GetService("ReplicatedStorage").wkspc.TimeScale.Value = 1
            if runServiceConnection then
                runServiceConnection:Disconnect()
                runServiceConnection = nil
            end
            if mouseDown then
                mouse1release()
                mouseDown = false
            end
        end
    end,
})











local Tab = Window:CreateTab("Gun", 4483362458) -- Title, Image









-- Variables to manage script state
local isRainbowActive = false
local rainbowConnection -- to keep track of the RenderStepped connection

-- Function to start the rainbow effect
local function startRainbowEffect()
    local c = 1
    local function zigzag(X)
        return math.acos(math.cos(X * math.pi)) / math.pi
    end
    rainbowConnection = game:GetService("RunService").RenderStepped:Connect(function()
        if game.Workspace.Camera:FindFirstChild('Arms') then
            for i, v in pairs(game.Workspace.Camera.Arms:GetDescendants()) do
                if v.ClassName == 'MeshPart' then
                    v.Color = Color3.fromHSV(zigzag(c), 1, 1)
                    c = c + 0.0001
                end
            end
        end
    end)
end

-- Function to stop the rainbow effect
local function stopRainbowEffect()
    if rainbowConnection then
        rainbowConnection:Disconnect()
        rainbowConnection = nil
    end
    -- Optionally, reset the color of MeshParts to their original color here if needed
end

-- Toggle Feature
local Toggle = Tab:CreateToggle({
    Name = "Rainbow Weapons",
    CurrentValue = false,
    Flag = nil, -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        isRainbowActive = Value
        if isRainbowActive then
            startRainbowEffect()
        else
            stopRainbowEffect()
        end
    end,
})

-- Optionally start the effect based on initial toggle state
if isRainbowActive then
    startRainbowEffect()
end









local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local originalValues = {
    FireRate = {},
    ReloadTime = {},
    EReloadTime = {},
    Auto = {},
    Spread = {},
    Recoil = {}
}

local ToggleInfiniteAmmo1 = Tab:CreateToggle({
    Name = "Infinite Ammo 1",
    CurrentValue = false,
    Flag = nil,
    Callback = function(v)
        ReplicatedStorage.wkspc.CurrentCurse.Value = v and "Infinite Ammo" or ""
    end,
})

local SettingsInfinite = false
local ToggleInfiniteAmmo2 = Tab:CreateToggle({
    Name = "Infinite Ammo 2",
    CurrentValue = false,
    Flag = nil,
    Callback = function(K)
        SettingsInfinite = K
        if SettingsInfinite then
            RunService.Stepped:Connect(function()
                pcall(function()
                    if SettingsInfinite then
                        local playerGui = Players.LocalPlayer.PlayerGui
                        playerGui.GUI.Client.Variables.ammocount.Value = 99
                        playerGui.GUI.Client.Variables.ammocount2.Value = 99
                    end
                end)
            end)
        end
    end,
})

local ToggleFastReload = Tab:CreateToggle({
    Name = "Fast Reload",
    CurrentValue = false,
    Flag = nil,
    Callback = function(x)
        for _, v in pairs(ReplicatedStorage.Weapons:GetChildren()) do
            if v:FindFirstChild("ReloadTime") then
                if x then
                    if not originalValues.ReloadTime[v] then
                        originalValues.ReloadTime[v] = v.ReloadTime.Value
                    end
                    v.ReloadTime.Value = 0.01
                else
                    if originalValues.ReloadTime[v] then
                        v.ReloadTime.Value = originalValues.ReloadTime[v]
                    else
                        v.ReloadTime.Value = 0.8 
                    end
                end
            end
            if v:FindFirstChild("EReloadTime") then
                if x then
                    if not originalValues.EReloadTime[v] then
                        originalValues.EReloadTime[v] = v.EReloadTime.Value
                    end
                    v.EReloadTime.Value = 0.01
                else
                    if originalValues.EReloadTime[v] then
                        v.EReloadTime.Value = originalValues.EReloadTime[v]
                    else
                        v.EReloadTime.Value = 0.8 
                    end
                end
            end
        end
    end,
})

local ToggleFastFireRate = Tab:CreateToggle({
    Name = "Fast Fire Rate",
    CurrentValue = false,
    Flag = nil,
    Callback = function(state)
        for _, v in pairs(ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "FireRate" or v.Name == "BFireRate" then
                if state then
                    if not originalValues.FireRate[v] then
                        originalValues.FireRate[v] = v.Value
                    end
                    v.Value = 0.02
                else
                    if originalValues.FireRate[v] then
                        v.Value = originalValues.FireRate[v]
                    else
                        v.Value = 0.8 
                    end
                end
            end
        end
    end,
})

ToggleAlwaysAuto = Tab:CreateToggle({
    Name = "Always Auto",
    CurrentValue = false,
    Flag = nil, 
    Callback = function(state)
        for _, v in pairs(ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "Auto" or v.Name == "AutoFire" or v.Name == "Automatic" or v.Name == "AutoShoot" or v.Name == "AutoGun" then
                if state then
                    if not originalValues.Auto[v] then
                        originalValues.Auto[v] = v.Value
                    end
                    v.Value = true
                else
                    if originalValues.Auto[v] then
                        v.Value = originalValues.Auto[v]
                    else
                        v.Value = false 
                    end
                end
            end
        end
    end,
})

ToggleNoSpread = Tab:CreateToggle({
    Name = "No Spread",
    CurrentValue = false,
    Flag = nil,
    Callback = function(state)
        for _, v in pairs(ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "MaxSpread" or v.Name == "Spread" or v.Name == "SpreadControl" then
                if state then
                    if not originalValues.Spread[v] then
                        originalValues.Spread[v] = v.Value
                    end
                    v.Value = 0
                else
                    if originalValues.Spread[v] then
                        v.Value = originalValues.Spread[v]
                    else
                        v.Value = 1 
                    end
                end
            end
        end
    end,
})

ToggleNoRecoil = Tab:CreateToggle({
    Name = "No Recoil",
    CurrentValue = false,
    Flag = nil,
    Callback = function(state)
        for _, v in pairs(ReplicatedStorage.Weapons:GetDescendants()) do
            if v.Name == "RecoilControl" or v.Name == "Recoil" then
                if state then
                    if not originalValues.Recoil[v] then
                        originalValues.Recoil[v] = v.Value
                    end
                    v.Value = 0
                else
                    if originalValues.Recoil[v] then
                        v.Value = originalValues.Recoil[v]
                    else
                        v.Value = 1 
                    end
                end
            end
        end
    end,
})
















local Tab = Window:CreateTab("Movement", 4483362458) -- Title, Image











local Section = Tab:CreateSection("No Clip",false) -- The 2nd argument is to tell if its only a Title and doesnt contain element







local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Create the UI toggle
local noclip = false -- Initialize noclip as false
local char = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()

-- Create Toggle
local Toggle = Tab:CreateToggle({
    Name = "Enable Noclip",
    CurrentValue = false,
    Flag = nil, -- Unique identifier for configuration saving
    Callback = function(Value)
        noclip = Value -- Update noclip based on toggle value
        if noclip then
            print("Noclip enabled.")
        else
            print("Noclip disabled.")
        end
    end,
})

-- Noclip functionality loop
RunService.Stepped:Connect(function()
    if noclip then
        for _, v in pairs(char:GetChildren()) do
            if v:IsA("Part") then
                pcall(function()
                    v.CanCollide = false -- Disable collision for parts
                end)
            end
        end
    end
end)

-- Update character reference when the player respawns
Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
    char = newChar -- Update the character reference
end)












Section = Tab:CreateSection("Flight",false) -- The 2nd argument is to tell if its only a Title and doesnt contain element




-- Initialization
local cloneref = cloneref or function(...) return ... end

local Players = cloneref(game:GetService("Players"))
local lp = Players.LocalPlayer

local flying = false
local bv, bav
local buttons = {W = false, S = false, A = false, D = false, Moving = false}
local flyKey = Enum.KeyCode.V -- Default keybind for fly
local flyToggle = false -- Variable to track toggle state
local flySpeed = 45 -- Default fly speed

local function StartFly()
    if not lp.Character then return end
    local c = lp.Character
    local h = c:FindFirstChildOfClass("Humanoid")
    if not h or flying then return end

    h.PlatformStand = true
    local cam = workspace.CurrentCamera

    bv = Instance.new("BodyVelocity")
    bav = Instance.new("BodyAngularVelocity")

    bv.Velocity, bv.MaxForce, bv.P = Vector3.new(0, 0, 0), Vector3.new(10000, 10000, 10000), 1000
    bav.AngularVelocity, bav.MaxTorque, bav.P = Vector3.new(0, 0, 0), Vector3.new(10000, 10000, 10000), 1000
    bv.Parent = c.Head
    bav.Parent = c.Head

    flying = true

    h.Died:connect(function() 
        EndFly()
    end)
end

local function EndFly()
    if bv then bv:Destroy() end
    if bav then bav:Destroy() end

    local c = lp.Character
    local h = c and c:FindFirstChildOfClass("Humanoid")
    if h then h.PlatformStand = false end

    flying = false
end

-- Handle user input for movement and flying activation
game:GetService("UserInputService").InputBegan:connect(function(input, GPE)
    if GPE then return end
    
    if flyToggle and input.KeyCode == flyKey then
        if flying then
            EndFly()
        else
            StartFly()
        end
    else
        for i, e in pairs(buttons) do
            if i ~= "Moving" and input.KeyCode == Enum.KeyCode[i] then
                buttons[i] = true
                buttons.Moving = true
            end
        end
    end
end)

game:GetService("UserInputService").InputEnded:connect(function(input, GPE)
    if GPE then return end
    local a = false
    for i, e in pairs(buttons) do
        if i ~= "Moving" then
            if input.KeyCode == Enum.KeyCode[i] then
                buttons[i] = false
            end
            if buttons[i] then a = true end
        end
    end
    buttons.Moving = a
end)

local function setVec(vec)
    return vec * (flySpeed / vec.Magnitude)
end

game:GetService("RunService").Heartbeat:connect(function(step)
    local c = cloneref(lp.Character)
    if flying and c and c.PrimaryPart then
        local p = c.PrimaryPart.Position
        local cf = workspace.CurrentCamera.CFrame
        local ax, ay, az = cf:toEulerAnglesXYZ()
        c:SetPrimaryPartCFrame(CFrame.new(p.x, p.y, p.z) * CFrame.Angles(ax, ay, az))
        if buttons.Moving then
            local t = Vector3.new()
            if buttons.W then t = t + (setVec(cf.lookVector)) end
            if buttons.S then t = t - (setVec(cf.lookVector)) end
            if buttons.A then t = t - (setVec(cf.rightVector)) end
            if buttons.D then t = t + (setVec(cf.rightVector)) end
            c:TranslateBy(t * step)
        end
    end
end)

-- Create a toggle for the fly script
local Toggle = Tab:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Flag = nil, -- Unique flag for saving settings
    Callback = function(Value)
        flyToggle = Value
        if Value then
            StartFly()
        else
            EndFly()
        end
    end,
})

-- Create a dropdown for keybind selection
local Dropdown = Tab:CreateDropdown({
    Name = "Fly Keybind",
    Options = {
        "W", "A", "S", "D", "Space", "LeftShift", "RightShift", "LeftControl", "RightControl",
        "Q", "E", "R", "T", "Y", "U", "I", "O", "P", 
        "1", "2", "3", "4", "5", "6", "7", "8", "9", "0",
        "F", "G", "H", "J", "K", "L", 
        "Z", "X", "C", "V", "B", "N", "M",
        "LeftArrow", "RightArrow", "UpArrow", "DownArrow"
    },
    CurrentOption = {"V"}, -- Default option
    MultipleOptions = false,
    Flag = nil, -- Unique flag for saving settings
    Callback = function(Option)
        -- Convert the selected option to KeyCode
        local keyMap = {
            W = Enum.KeyCode.W,
            A = Enum.KeyCode.A,
            S = Enum.KeyCode.S,
            D = Enum.KeyCode.D,
            Space = Enum.KeyCode.Space,
            LeftShift = Enum.KeyCode.LeftShift,
            RightShift = Enum.KeyCode.RightShift,
            LeftControl = Enum.KeyCode.LeftControl,
            RightControl = Enum.KeyCode.RightControl,
            Q = Enum.KeyCode.Q,
            E = Enum.KeyCode.E,
            R = Enum.KeyCode.R,
            T = Enum.KeyCode.T,
            Y = Enum.KeyCode.Y,
            U = Enum.KeyCode.U,
            I = Enum.KeyCode.I,
            O = Enum.KeyCode.O,
            P = Enum.KeyCode.P,
            ["1"] = Enum.KeyCode.One,
            ["2"] = Enum.KeyCode.Two,
            ["3"] = Enum.KeyCode.Three,
            ["4"] = Enum.KeyCode.Four,
            ["5"] = Enum.KeyCode.Five,
            ["6"] = Enum.KeyCode.Six,
            ["7"] = Enum.KeyCode.Seven,
            ["8"] = Enum.KeyCode.Eight,
            ["9"] = Enum.KeyCode.Nine,
            ["0"] = Enum.KeyCode.Zero,
            F = Enum.KeyCode.F,
            G = Enum.KeyCode.G,
            H = Enum.KeyCode.H,
            J = Enum.KeyCode.J,
            K = Enum.KeyCode.K,
            L = Enum.KeyCode.L,
            Z = Enum.KeyCode.Z,
            X = Enum.KeyCode.X,
            C = Enum.KeyCode.C,
            V = Enum.KeyCode.V,
            B = Enum.KeyCode.B,
            N = Enum.KeyCode.N,
            M = Enum.KeyCode.M,
            LeftArrow = Enum.KeyCode.Left,
            RightArrow = Enum.KeyCode.Right,
            UpArrow = Enum.KeyCode.Up,
            DownArrow = Enum.KeyCode.Down
        }
        flyKey = keyMap[Option[1]] or Enum.KeyCode.V
        print("Fly keybind set to: " .. Option[1])
    end,
})

-- Create an input box for adjusting the fly speed
local Input = Tab:CreateInput({
    Name = "Fly Speed",
    PlaceholderText = "Enter Fly Speed (10-200)",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local number = tonumber(Text)
        if number and number >= 10 and number <= 200 then
            flySpeed = number
            print("Fly speed set to: " .. flySpeed)
        else
            print("Invalid input for fly speed. Please enter a number between 10 and 200.")
        end
    end,
})







Section = Tab:CreateSection("Speed",false) -- The 2nd argument is to tell if its only a Title and doesnt contain element


local localPlayer = game:GetService("Players").LocalPlayer
local uis = game:GetService("UserInputService")
local isRunning = false
local speed = 1  -- Default speed multiplier
local toggleEnabled = false
local keybind = Enum.KeyCode.Q  -- Default keybind

-- Function to handle character running
local function handleRunning()
    while isRunning do
        task.wait()
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame + localPlayer.Character.HumanoidRootPart.CFrame.lookVector * speed
        end
    end
end

-- Toggle button setup
Toggle = Tab:CreateToggle({
    Name = "Speed",
    CurrentValue = false,
    Flag = nil, -- A flag is the identifier for the configuration file
    Callback = function(Value)
        toggleEnabled = Value
        if toggleEnabled and isRunning then
            task.spawn(handleRunning)  -- Ensure running starts if toggle is enabled
        else
            stopRunning()
        end
    end,
})

-- Input box setup for speed
SpeedInput = Tab:CreateInput({
    Name = "Speed Multiplier | Recommended Speed (0.4)",
    PlaceholderText = "Enter Speed (Max 1)",
    NumbersOnly = true, -- Only allow numbers
    CharacterLimit = 10, -- Max character limit
    OnEnter = true,
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local newSpeed = tonumber(Text)
        if newSpeed then
            if newSpeed > 1 then
                newSpeed = 1
            end
            speed = newSpeed
            print("Speed updated to: " .. speed)
        else
            print("Invalid speed: " .. Text)
        end
    end,
})

-- Input box setup for keybind
KeybindInput = Tab:CreateInput({
    Name = "Speed Keybind",
    PlaceholderText = "Enter Keybind",
    NumbersOnly = false, -- Allow all characters, including letters
    CharacterLimit = 15, -- Max character limit
    OnEnter = true,
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local keyCode = Enum.KeyCode[Text:upper()]  -- Convert the input text to an Enum.KeyCode
        if keyCode then
            keybind = keyCode
        else
            print("Invalid keybind: " .. Text)
        end
    end,
})

-- Function to stop running
local function stopRunning()
    isRunning = false
end

-- Connect the InputBegan event to toggle running based on the keybind
uis.InputBegan:Connect(function(i, gp)
    if gp then return end
    if i.KeyCode == keybind then
        if toggleEnabled then
            if isRunning then
                stopRunning()
            else
                isRunning = true
                task.spawn(handleRunning)  -- Ensure running starts if toggle is enabled
            end
        end
    end
end)







Section = Tab:CreateSection("Teleportation")








-- Variables to store the toggle state and user-defined keybind
local isTeleportEnabled = false
local keybind = nil  -- No default keybind

-- Function to handle the toggle callback
local function onToggleChanged(value)
    isTeleportEnabled = value
end

-- Function to handle the input box callback
local function onInputChanged(text)
    -- Convert input text to a KeyCode
    local keyCode = Enum.KeyCode[text:upper()]
    if keyCode then
        keybind = keyCode
    else
        warn("Invalid keybind entered: " .. text)
    end
end

-- Create Toggle
Toggle = Tab:CreateToggle({
    Name = "Teleport",
    CurrentValue = false,
    Flag = nil,
    Callback = onToggleChanged,
})

-- Create Input
Input = Tab:CreateInput({
    Name = "Teleport Keybind",
    PlaceholderText = "Enter Keybind",
    RemoveTextAfterFocusLost = false,
    Callback = onInputChanged,
})

-- Function to handle teleportation
local function onTeleport()
    if isTeleportEnabled then
        local mouse = game.Players.LocalPlayer:GetMouse()
        local targetPosition = mouse.Hit.Position

        -- Teleport the player to the target position
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
    end
end

-- Connect keybind to teleportation
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == keybind then
        onTeleport()
    end
end)












Section = Tab:CreateSection("Inf Jump")






-- Define the Toggle State and Jump Height
local toggleOn = false
local jumpHeight = 10 -- Default jump height

-- Toggle Creation
local Toggle = Tab:CreateToggle({
    Name = "Inf Jump",
    CurrentValue = false,
    Flag = nil, -- Ensure the flag is unique for configuration saving
    Callback = function(Value)
        toggleOn = Value
    end,
})

-- Slider Creation
Slider = Tab:CreateSlider({
    Name = "Jump Height",
    Range = {0, 100},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = 10,
    Flag = nil, -- A flag is the identifier for the configuration file
    Callback = function(Value)
        jumpHeight = Value
    end,
})

-- Local Player and Mouse setup
local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()

-- Handle KeyDown event
Mouse.KeyDown:connect(function(k)
    if toggleOn and k:byte() == 32 then -- Check if toggle is on and space key is pressed
        local Humanoid = Player.Character and Player.Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            -- Modify jump height based on slider value
            local Character = Player.Character
            if Character and Character:FindFirstChild("HumanoidRootPart") then
                local HRP = Character.HumanoidRootPart
                local BodyVelocity = HRP:FindFirstChildOfClass("BodyVelocity") or Instance.new("BodyVelocity")
                BodyVelocity.Name = "BodyVelocity"
                BodyVelocity.Velocity = Vector3.new(0, jumpHeight, 0)
                BodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
                BodyVelocity.Parent = HRP
                
                -- Remove BodyVelocity after jump
                wait(0.1)
                BodyVelocity:Destroy()
            end
        end
    end
end)







Tab = Window:CreateTab("Skins", 4483362458) -- Title, Image




local Section = Tab:CreateSection("Gun Skins")



-- Gun skin section without label
local at = "Plastic"
Dropdown = Tab:CreateDropdown({
    Name = "Gun Material",
    Options = {"Plastic", "ForceField", "Wood", "Grass"},
    CurrentOption = {"Plastic"},
    MultipleOptions = false,
    Flag = nil, -- Unique identifier for configuration
    Callback = function(selectedOption)
        at = selectedOption[1] -- Store the selected material
    end,
})

-- Default gun color
local au = Color3.fromRGB(50, 50, 50)
ColorPicker = Tab:CreateColorPicker({
    Name = "Gun Color",
    Color = au,
    Flag = nil, -- Unique identifier for configuration
    Callback = function(selectedColor)
        au = selectedColor -- Store the selected color
    end,
})

local av = false
Toggle = Tab:CreateToggle({
    Name = "Enable Gun Settings",
    CurrentValue = false,
    Flag = nil, -- Unique identifier for configuration
    Callback = function(isActive)
        av = isActive
        if av then
            spawn(function()
                while true do
                    wait(0.01)
                    if not av then
                        break
                    else
                        if not workspace.Camera:FindFirstChild("Arms") then
                            wait()
                        else
                            for _, O in pairs(workspace.Camera.Arms:GetDescendants()) do
                                if O:IsA("MeshPart") then
                                    O.Material = Enum.Material[at]
                                    O.Color = au
                                end
                            end
                        end
                    end
                end
            end)
        end
    end,
})




local Tab = Window:CreateTab("Player", 4483362458) -- Title, Image



local Section = Tab:CreateSection("Misc")



local xrayOn = false

Toggle = Tab:CreateToggle({
    Name = "Xray",
    CurrentValue = false,
    Flag = nil,  -- Ensure this flag is unique for configuration saving
    Callback = function(enabled)
        xrayOn = enabled

        if xrayOn then
            for _, descendant in pairs(workspace:GetDescendants()) do
                if descendant:IsA("BasePart") then
                    if not descendant:FindFirstChild("OriginalTransparency") then
                        local originalTransparency = Instance.new("NumberValue")
                        originalTransparency.Name = "OriginalTransparency"
                        originalTransparency.Value = descendant.Transparency
                        originalTransparency.Parent = descendant
                    end
                    descendant.Transparency = 0.5
                end
            end
        else
            for _, descendant in pairs(workspace:GetDescendants()) do
                if descendant:IsA("BasePart") then
                    if descendant:FindFirstChild("OriginalTransparency") then
                        descendant.Transparency = descendant.OriginalTransparency.Value
                        descendant.OriginalTransparency:Destroy()
                    end
                end
            end
        end
    end,
})






FOVSlider = Tab:CreateSlider({
    Name = "FOV",
    Range = {0, 120},  -- Set the range from 0 to 120
    Increment = 1,     -- Increment by 1 for more precise control
    Suffix = "FOV",    -- Optional suffix
    CurrentValue = game:GetService("Players").LocalPlayer.Settings.FOV.Value,  -- Set the current value from the player's settings
    Flag = "FOVSlider", -- Unique flag for configuration saving
    Callback = function(num)
        game:GetService("Players").LocalPlayer.Settings.FOV.Value = num  -- Update FOV setting
    end,
})




local Section = Tab:CreateSection("Auto")





local autoHealEnabled = false
local autoAmmoEnabled = false

Toggle = Tab:CreateToggle({
    Name = "Auto bring HP Jugs",
    CurrentValue = false,
    Flag = nil,  -- Unique flag for configuration saving
    Callback = function(enabled)
        autoHealEnabled = enabled
        managePickups()
    end,
})

Toggle = Tab:CreateToggle({
    Name = "Auto bring Ammo Boxes",
    CurrentValue = false,
    Flag = nil, -- Unique flag for configuration saving
    Callback = function(enabled)
        autoAmmoEnabled = enabled
        managePickups()
    end,
})

function managePickups()
    if autoHealEnabled or autoAmmoEnabled then
        spawn(function()
            while autoHealEnabled or autoAmmoEnabled do
                wait()
                pcall(function()
                    local player = game.Players.LocalPlayer
                    local character = player.Character
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            for _, v in pairs(game.Workspace.Debris:GetChildren()) do
                                if (autoHealEnabled and v.Name == "DeadHP") or (autoAmmoEnabled and v.Name == "DeadAmmo") then
                                    v.CFrame = humanoidRootPart.CFrame
                                end
                            end
                        end
                    end
                end)
            end
        end)
    end
end







Tab = Window:CreateTab("ESP", 4483362458) -- Title, Image



-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Configuration for Name ESP
local config = {
    ESP = {
        Name = {
            Name = true,
            TeamCheck = true,
            TeamColor = true
        }
    }
}

-- Toggle state variable
local isToggleOn = false

-- Create and update Name ESP
local function createNameESP(playerCharacter)
    -- Create ESP GUI elements
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = playerCharacter.Character:FindFirstChild("Head") or playerCharacter.Character
    billboardGui.Name = playerCharacter.Name .. "_NameESP"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(4, 0, 5.4, 0)
    billboardGui.ClipsDescendants = false
    billboardGui.Enabled = false

    local nameLabel = Instance.new("TextLabel", billboardGui)
    nameLabel.Name = "namelabel"
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Size = UDim2.new(0, 100, 0, 18)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.Text = playerCharacter.Name

    -- Coroutine to update Name ESP
    local coroutineTask = coroutine.create(function()
        while wait(0.1) do
            if playerCharacter and playerCharacter.Character and playerCharacter.Character:FindFirstChild("Humanoid") and (playerCharacter.Character.Humanoid.Health > 0) then
                if isToggleOn then
                    billboardGui.Adornee = playerCharacter.Character.HumanoidRootPart
                    nameLabel.Text = playerCharacter.Name

                    if config.ESP.Name.Name then
                        nameLabel.Visible = true
                    else
                        nameLabel.Visible = false
                    end

                    if config.ESP.Name.TeamCheck and (playerCharacter.TeamColor == Players.LocalPlayer.TeamColor) then
                        billboardGui.Enabled = false
                    else
                        billboardGui.Enabled = true
                    end

                    if config.ESP.Name.TeamColor then
                        nameLabel.TextColor3 = playerCharacter.TeamColor.Color
                    else
                        nameLabel.TextColor3 = Color3.fromRGB(0, 0, 0)  -- Black color
                    end

                    if not Players:FindFirstChild(playerCharacter.Name) then
                        billboardGui:Destroy()
                        coroutine.yield()
                    end
                else
                    billboardGui.Enabled = false
                    billboardGui.Adornee = nil
                    nameLabel.Visible = false
                end
            else
                billboardGui.Enabled = false
                billboardGui.Adornee = nil
                nameLabel.Visible = false
            end
        end
    end)

    coroutine.resume(coroutineTask)
end

-- Toggle callback
local Toggle = Tab:CreateToggle({
    Name = "Name Esp",
    CurrentValue = false,
    Flag = nil, -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        isToggleOn = Value
        -- Update all existing ESPs based on the new toggle state
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Character then
                local billboardGui = player.Character:FindFirstChild(player.Name .. "_NameESP")
                if billboardGui then
                    billboardGui.Enabled = isToggleOn
                end
            end
        end
    end,
})

-- Connect player events
Players.PlayerAdded:Connect(function(playerCharacter)
    playerCharacter.CharacterAdded:Connect(function()
        createNameESP(playerCharacter)
    end)
end)

-- Handle existing players
for _, playerCharacter in ipairs(Players:GetPlayers()) do
    if playerCharacter.Character then
        createNameESP(playerCharacter)
    end
end










-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Configuration for ESP
local config = {
    ESP = {
        Box = {
            Box = true,
            TeamCheck = true,
            BoxColor = Color3.fromRGB(0, 0, 0),
            TeamColor = true
        }
    }
}

-- Toggle state variable
local isToggleOn = false

-- Create and update ESP boxes
local function createBoxESP(playerCharacter)
    -- Create ESP GUI elements
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = playerCharacter.Character:FindFirstChild("HumanoidRootPart") or playerCharacter.Character
    billboardGui.Name = playerCharacter.Name .. "_BoxESP"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(4, 0, 5.4, 0)
    billboardGui.ClipsDescendants = false
    billboardGui.Enabled = false

    local frame = Instance.new("Frame", billboardGui)
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BorderSizePixel = 1
    frame.BackgroundTransparency = 1

    local topFrame = Instance.new("Frame", frame)
    topFrame.BorderSizePixel = 1
    topFrame.Size = UDim2.new(1, 0, 0, 2)
    topFrame.Position = UDim2.new(0, 0, 0, 0)

    local bottomFrame = Instance.new("Frame", frame)
    bottomFrame.BorderSizePixel = 1
    bottomFrame.Size = UDim2.new(1, 0, 0, 2)
    bottomFrame.Position = UDim2.new(0, 0, 1, -2)

    local leftFrame = Instance.new("Frame", frame)
    leftFrame.BorderSizePixel = 1
    leftFrame.Size = UDim2.new(0, 2, 1, 0)
    leftFrame.Position = UDim2.new(0, 0, 0, 0)

    local rightFrame = Instance.new("Frame", frame)
    rightFrame.BorderSizePixel = 1
    rightFrame.Size = UDim2.new(0, 2, 1, 0)
    rightFrame.Position = UDim2.new(1, -2, 0, 0)

    -- Coroutine to update ESP boxes
    local coroutineTask = coroutine.create(function()
        while wait(0.1) do
            if playerCharacter and playerCharacter.Character and playerCharacter.Character:FindFirstChild("Humanoid") and (playerCharacter.Character.Humanoid.Health > 0) then
                if isToggleOn then
                    billboardGui.Adornee = playerCharacter.Character.HumanoidRootPart

                    if config.ESP.Box.Box then
                        frame.Visible = true
                    else
                        frame.Visible = false
                    end

                    if config.ESP.Box.TeamCheck and (playerCharacter.TeamColor == Players.LocalPlayer.TeamColor) then
                        billboardGui.Enabled = false
                    else
                        billboardGui.Enabled = true
                    end

                    local color = config.ESP.Box.BoxColor
                    if config.ESP.Box.TeamColor then
                        color = playerCharacter.TeamColor.Color
                    end

                    topFrame.BackgroundColor3 = color
                    bottomFrame.BackgroundColor3 = color
                    leftFrame.BackgroundColor3 = color
                    rightFrame.BackgroundColor3 = color
                    frame.BackgroundColor3 = color
                else
                    billboardGui.Enabled = false
                    billboardGui.Adornee = nil
                    frame.Visible = false
                end

                if not Players:FindFirstChild(playerCharacter.Name) then
                    billboardGui:Destroy()
                    coroutine.yield()
                end
            else
                billboardGui.Enabled = false
                billboardGui.Adornee = nil
                frame.Visible = false
            end
        end
    end)

    coroutine.resume(coroutineTask)
end

-- Toggle callback
Toggle = Tab:CreateToggle({
    Name = "Box Esp",
    CurrentValue = false,
    Flag = nil, -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        isToggleOn = Value
        -- Update all existing ESPs based on the new toggle state
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Character then
                local billboardGui = player.Character:FindFirstChild(player.Name .. "_BoxESP")
                if billboardGui then
                    billboardGui.Enabled = isToggleOn
                    billboardGui:FindFirstChild("Frame").Visible = isToggleOn
                end
            end
        end
    end,
})

-- Connect player events
Players.PlayerAdded:Connect(function(playerCharacter)
    playerCharacter.CharacterAdded:Connect(function()
        createBoxESP(playerCharacter)
    end)
end)

-- Handle existing players
for _, playerCharacter in ipairs(Players:GetPlayers()) do
    if playerCharacter.Character then
        createBoxESP(playerCharacter)
    end
end








local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local isBoxesEnabled = false  -- Start with boxes disabled
local boxes = {}

local function createBox()
    local box = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Color = Color3.new(1, 1, 1)  -- Set color to white
        line.Thickness = 2
        line.Transparency = 1
        line.Visible = false  -- Initially not visible
        box[i] = line
    end
    return box
end

local function updateBox(box, position, size)
    local corners = {
        position + Vector3.new(-size.X, size.Y, -size.Z) / 2,
        position + Vector3.new(size.X, size.Y, -size.Z) / 2,
        position + Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        position + Vector3.new(size.X, -size.Y, -size.Z) / 2,
        position + Vector3.new(-size.X, size.Y, size.Z) / 2,
        position + Vector3.new(size.X, size.Y, size.Z) / 2,
        position + Vector3.new(-size.X, -size.Y, size.Z) / 2,
        position + Vector3.new(size.X, -size.Y, size.Z) / 2
    }

    local screenCorners = {}
    for _, corner in ipairs(corners) do
        local screenPos, onScreen = Camera:WorldToViewportPoint(corner)
        table.insert(screenCorners, {pos = screenPos, visible = onScreen})
    end

    if #screenCorners == 8 then
        local lines = {
            {1, 2}, {2, 4}, {4, 3}, {3, 1},
            {5, 6}, {6, 8}, {8, 7}, {7, 5},
            {1, 5}, {2, 6}, {3, 7}, {4, 8}
        }

        for i, line in ipairs(lines) do
            if screenCorners[line[1]].visible and screenCorners[line[2]].visible then
                box[i].From = Vector2.new(screenCorners[line[1]].pos.X, screenCorners[line[1]].pos.Y)
                box[i].To = Vector2.new(screenCorners[line[2]].pos.X, screenCorners[line[2]].pos.Y)
                box[i].Visible = isBoxesEnabled  -- Show or hide based on toggle
            else
                box[i].Visible = false
            end
        end
    end
end

local function toggleBoxes(value)
    isBoxesEnabled = value
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        boxes[player] = createBox()
    end
end

RunService.RenderStepped:Connect(function()
    for player, box in pairs(boxes) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local position = player.Character.HumanoidRootPart.Position
            local size = player.Character:GetExtentsSize()
            updateBox(box, position, size)
        else
            for _, line in ipairs(box) do
                line.Visible = false  -- Hide the box if the player is not in the game
            end
        end
    end
end)

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        boxes[player] = createBox()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if boxes[player] then
        for _, part in pairs(boxes[player]) do
            part:Remove()
        end
        boxes[player] = nil
    end
end)

-- Create toggle for enabling/disabling boxes
Toggle = Tab:CreateToggle({
    Name = "3d box Esp",
    CurrentValue = false,
    Flag = nil,  -- Unique identifier for configuration saving
    Callback = function(Value)
        toggleBoxes(Value)
        -- Update visibility of all boxes based on the toggle state
        for _, box in pairs(boxes) do
            for _, line in ipairs(box) do
                line.Visible = Value
            end
        end
    end,
})











-- Dependencies
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Get the local player and the camera
local localPlayer = Players.LocalPlayer
local currentCamera = Workspace.CurrentCamera

-- Variable to keep track of Distance ESP toggle state
local distanceESPEnabled = false

-- Container for BillboardGui objects
local distanceDisplays = {}

-- Function to calculate distance from the camera to a part
local function getDistanceFromCamera(part)
    return (part.Position - currentCamera.CFrame.Position).Magnitude
end

-- Function to create and display the BillboardGui
local function createDistanceDisplay(player)
    local character = player.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    -- Create the BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = player.Name .. "_DistanceDisplay"
    billboardGui.Parent = humanoidRootPart
    billboardGui.Size = UDim2.new(0, 60, 0, 50) -- Size of the BillboardGui
    billboardGui.Adornee = humanoidRootPart
    billboardGui.AlwaysOnTop = true
    billboardGui.StudsOffset = Vector3.new(3, 0, 0) -- Position to the right of the player
    billboardGui.ClipsDescendants = true

    -- Create the TextLabel
    local textLabel = Instance.new("TextLabel")
    textLabel.Parent = billboardGui
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextScaled = true
    textLabel.Text = "Distance: 0 "

    -- Update the distance display
    local function updateDistance()
        local distance = math.floor(getDistanceFromCamera(humanoidRootPart))
        textLabel.Text = string.format("Distance: %d ", distance)
    end

    -- Connect to RenderStepped to update the distance
    local renderConnection
    renderConnection = RunService.RenderStepped:Connect(function()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            billboardGui:Destroy()
            if renderConnection then
                renderConnection:Disconnect()
            end
        else
            updateDistance()
        end
    end)

    -- Store the billboardGui in the distanceDisplays table
    distanceDisplays[player] = billboardGui
end

-- Function to handle player addition
local function onPlayerAdded(player)
    if distanceESPEnabled and player.Character then
        createDistanceDisplay(player)
    end
    player.CharacterAdded:Connect(function()
        if distanceESPEnabled then
            createDistanceDisplay(player)
        end
    end)
end

-- Function to handle player removal
local function onPlayerRemoving(player)
    if distanceDisplays[player] then
        distanceDisplays[player]:Destroy()
        distanceDisplays[player] = nil
    end
end

-- Toggle functionality
local function toggleDistanceESP(shouldEnable)
    if shouldEnable == distanceESPEnabled then return end

    -- Turn off Distance ESP
    if not shouldEnable then
        for _, display in pairs(distanceDisplays) do
            display:Destroy()
        end
        distanceDisplays = {}
        distanceESPEnabled = false
    else
        -- Turn on Distance ESP
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then
                local character = player.Character
                if character then
                    createDistanceDisplay(player)
                end
            end
        end

        -- Start listening for new players
        Players.PlayerAdded:Connect(onPlayerAdded)
        Players.PlayerRemoving:Connect(onPlayerRemoving)

        distanceESPEnabled = true
    end
end

Toggle = Tab:CreateToggle({
    Name = "Distance Esp",  -- Title of the toggle
    CurrentValue = false,   -- Default value (off)
    Flag = nil,  -- Unique flag for configuration
    Callback = function(value)
        toggleDistanceESP(value)
    end,
})
















-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Configuration for Health ESP
local config = {
    ESP = {
        Health = {
            Enabled = false,  -- Start with health ESP disabled
            Position = UDim2.new(0, 0, 1, 0),  -- Position on the left side of the player
            Size = UDim2.new(0.04, 0, 1, 0),      -- Width and height of the health bar
            BackgroundColor = Color3.fromRGB(40, 40, 40),
            BarColor = Color3.fromRGB(94, 255, 69),
        }
    }
}

-- Toggle state variable
local healthESPEnabled = config.ESP.Health.Enabled

-- Toggle function
local function onToggleChanged(value)
    healthESPEnabled = value
    -- Update all existing health bars based on new toggle state
    for _, playerCharacter in ipairs(Players:GetPlayers()) do
        if playerCharacter.Character and playerCharacter.Character:FindFirstChild("HumanoidRootPart") then
            local existingESP = Workspace.CurrentCamera:FindFirstChild(playerCharacter.Name .. "_HealthBarESP")
            if existingESP then
                existingESP.Enabled = healthESPEnabled
            end
        end
    end
end

-- Create and update Health Bar ESP
local function createHealthBarESP(playerCharacter)
    -- Create ESP GUI elements
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = Workspace.CurrentCamera
    billboardGui.Name = playerCharacter.Name .. "_HealthBarESP"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(4.5, 0, 6, 0)
    billboardGui.ClipsDescendants = false
    billboardGui.Enabled = healthESPEnabled

    local healthBarContainer = Instance.new("Frame", billboardGui)
    healthBarContainer.Name = "HealthBarContainer"
    healthBarContainer.Size = config.ESP.Health.Size
    healthBarContainer.Position = config.ESP.Health.Position
    healthBarContainer.BackgroundColor3 = config.ESP.Health.BackgroundColor
    healthBarContainer.BorderSizePixel = 0

    local healthBar = Instance.new("Frame", healthBarContainer)
    healthBar.Name = "HealthBar"
    healthBar.Size = UDim2.new(0.8, 0, 0.8, 0)
    healthBar.BackgroundColor3 = config.ESP.Health.BarColor
    healthBar.BorderSizePixel = 0
    healthBar.AnchorPoint = Vector2.new(0, 1)
    healthBar.Position = UDim2.new(0, 0, 0, 0)

    -- Coroutine to update Health Bar
    local coroutineTask = coroutine.create(function()
        while wait(0.1) do
            if (playerCharacter ~= Players.LocalPlayer) and playerCharacter and playerCharacter.Character and playerCharacter.Character:FindFirstChild("Humanoid") and (playerCharacter.Character.Humanoid.Health > 0) then
                billboardGui.Adornee = playerCharacter.Character.HumanoidRootPart

                -- Update health bar
                local humanoid = playerCharacter.Character:FindFirstChild("Humanoid")
                if humanoid then
                    local healthRatio = humanoid.Health / humanoid.MaxHealth
                    healthBar.Size = UDim2.new(1, 0, healthRatio, 0)
                end

                -- Update health bar visibility
                billboardGui.Enabled = healthESPEnabled

                if not Players:FindFirstChild(playerCharacter.Name) then
                    billboardGui:Destroy()
                    coroutine.yield()
                end
            else
                billboardGui.Enabled = false
                billboardGui.Adornee = nil
            end
        end
    end)

    coroutine.resume(coroutineTask)
end

-- Connect player events
Players.PlayerAdded:Connect(function(playerCharacter)
    playerCharacter.CharacterAdded:Connect(function()
        createHealthBarESP(playerCharacter)
    end)
end)

-- Handle existing players
for _, playerCharacter in ipairs(Players:GetPlayers()) do
    if playerCharacter.Character then
        createHealthBarESP(playerCharacter)
    end
end

-- Integrate toggle
Toggle = Tab:CreateToggle({
    Name = "Health Esp",
    CurrentValue = config.ESP.Health.Enabled,
    Flag = nil, -- Ensure flag is unique for configuration saving
    Callback = onToggleChanged,
})












local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local Camera = game:GetService("Workspace").CurrentCamera
local RunService = game:GetService("RunService")

local espEnabled = false -- Start with ESP disabled

local function DrawLine()
    local l = Drawing.new("Line")
    l.Visible = false
    l.From = Vector2.new(0, 0)
    l.To = Vector2.new(1, 1)
    l.Color = Color3.fromRGB(255, 255, 255)
    l.Thickness = 1
    l.Transparency = 1
    return l
end

local function DrawESP(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    
    local limbs = {}
    local R15 = plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15

    if R15 then 
        limbs = {
            Head_UpperTorso = DrawLine(),
            UpperTorso_LowerTorso = DrawLine(),
            UpperTorso_LeftUpperArm = DrawLine(),
            LeftUpperArm_LeftLowerArm = DrawLine(),
            LeftLowerArm_LeftHand = DrawLine(),
            UpperTorso_RightUpperArm = DrawLine(),
            RightUpperArm_RightLowerArm = DrawLine(),
            RightLowerArm_RightHand = DrawLine(),
            LowerTorso_LeftUpperLeg = DrawLine(),
            LeftUpperLeg_LeftLowerLeg = DrawLine(),
            LeftLowerLeg_LeftFoot = DrawLine(),
            LowerTorso_RightUpperLeg = DrawLine(),
            RightUpperLeg_RightLowerLeg = DrawLine(),
            RightLowerLeg_RightFoot = DrawLine(),
        }
    else 
        limbs = {
            Head_Spine = DrawLine(),
            Spine = DrawLine(),
            LeftArm = DrawLine(),
            LeftArm_UpperTorso = DrawLine(),
            RightArm = DrawLine(),
            RightArm_UpperTorso = DrawLine(),
            LeftLeg = DrawLine(),
            LeftLeg_LowerTorso = DrawLine(),
            RightLeg = DrawLine(),
            RightLeg_LowerTorso = DrawLine(),
        }
    end

    local function UpdateVisibility(state)
        for _, line in pairs(limbs) do
            line.Visible = state
        end
    end

    local function UpdateESP()
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if espEnabled and plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 then
                local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if vis then
                    local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)

                    -- Update positions for R15 or R6
                    if R15 then
                        local UT = Camera:WorldToViewportPoint(plr.Character.UpperTorso.Position)
                        local LT = Camera:WorldToViewportPoint(plr.Character.LowerTorso.Position)
                        -- Left Arm
                        local LUA = Camera:WorldToViewportPoint(plr.Character.LeftUpperArm.Position)
                        local LLA = Camera:WorldToViewportPoint(plr.Character.LeftLowerArm.Position)
                        local LH = Camera:WorldToViewportPoint(plr.Character.LeftHand.Position)
                        -- Right Arm
                        local RUA = Camera:WorldToViewportPoint(plr.Character.RightUpperArm.Position)
                        local RLA = Camera:WorldToViewportPoint(plr.Character.RightLowerArm.Position)
                        local RH = Camera:WorldToViewportPoint(plr.Character.RightHand.Position)
                        -- Left Leg
                        local LUL = Camera:WorldToViewportPoint(plr.Character.LeftUpperLeg.Position)
                        local LLL = Camera:WorldToViewportPoint(plr.Character.LeftLowerLeg.Position)
                        local LF = Camera:WorldToViewportPoint(plr.Character.LeftFoot.Position)
                        -- Right Leg
                        local RUL = Camera:WorldToViewportPoint(plr.Character.RightUpperLeg.Position)
                        local RLL = Camera:WorldToViewportPoint(plr.Character.RightLowerLeg.Position)
                        local RF = Camera:WorldToViewportPoint(plr.Character.RightFoot.Position)

                        -- Set line positions
                        limbs.Head_UpperTorso.From = Vector2.new(H.X, H.Y)
                        limbs.Head_UpperTorso.To = Vector2.new(UT.X, UT.Y)

                        limbs.UpperTorso_LowerTorso.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_LowerTorso.To = Vector2.new(LT.X, LT.Y)

                        limbs.UpperTorso_LeftUpperArm.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_LeftUpperArm.To = Vector2.new(LUA.X, LUA.Y)

                        limbs.LeftUpperArm_LeftLowerArm.From = Vector2.new(LUA.X, LUA.Y)
                        limbs.LeftUpperArm_LeftLowerArm.To = Vector2.new(LLA.X, LLA.Y)

                        limbs.LeftLowerArm_LeftHand.From = Vector2.new(LLA.X, LLA.Y)
                        limbs.LeftLowerArm_LeftHand.To = Vector2.new(LH.X, LH.Y)

                        limbs.UpperTorso_RightUpperArm.From = Vector2.new(UT.X, UT.Y)
                        limbs.UpperTorso_RightUpperArm.To = Vector2.new(RUA.X, RUA.Y)

                        limbs.RightUpperArm_RightLowerArm.From = Vector2.new(RUA.X, RUA.Y)
                        limbs.RightUpperArm_RightLowerArm.To = Vector2.new(RLA.X, RLA.Y)

                        limbs.RightLowerArm_RightHand.From = Vector2.new(RLA.X, RLA.Y)
                        limbs.RightLowerArm_RightHand.To = Vector2.new(RH.X, RH.Y)

                        limbs.LowerTorso_LeftUpperLeg.From = Vector2.new(LT.X, LT.Y)
                        limbs.LowerTorso_LeftUpperLeg.To = Vector2.new(LUL.X, LUL.Y)

                        limbs.LeftUpperLeg_LeftLowerLeg.From = Vector2.new(LUL.X, LUL.Y)
                        limbs.LeftUpperLeg_LeftLowerLeg.To = Vector2.new(LLL.X, LLL.Y)

                        limbs.LeftLowerLeg_LeftFoot.From = Vector2.new(LLL.X, LLL.Y)
                        limbs.LeftLowerLeg_LeftFoot.To = Vector2.new(LF.X, LF.Y)

                        limbs.LowerTorso_RightUpperLeg.From = Vector2.new(LT.X, LT.Y)
                        limbs.LowerTorso_RightUpperLeg.To = Vector2.new(RUL.X, RUL.Y)

                        limbs.RightUpperLeg_RightLowerLeg.From = Vector2.new(RUL.X, RUL.Y)
                        limbs.RightUpperLeg_RightLowerLeg.To = Vector2.new(RLL.X, RLL.Y)

                        limbs.RightLowerLeg_RightFoot.From = Vector2.new(RLL.X, RLL.Y)
                        limbs.RightLowerLeg_RightFoot.To = Vector2.new(RF.X, RF.Y)

                        UpdateVisibility(true) -- Ensure visibility when player is visible
                    else
                        -- R6 logic here (similar updates as R15)
                        -- You can add the R6 updating logic similar to R15
                    end
                else
                    UpdateVisibility(false) -- Hide if not visible
                end
            else
                UpdateVisibility(false) -- Hide if dead or not in game
                if not game.Players:FindFirstChild(plr.Name) then
                    connection:Disconnect() -- Disconnect if player leaves
                end
            end
        end)
    end

    coroutine.wrap(UpdateESP)()
end

for _, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= Player.Name then
        DrawESP(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= Player.Name then
        DrawESP(newplr)
    end
end)

-- Create the toggle for ESP
Toggle = Tab:CreateToggle({
    Name = "Skeleton Esp",
    CurrentValue = false,
    Flag = nil, -- Unique flag
    Callback = function(Value)
        espEnabled = Value -- Update espEnabled based on toggle state
        for _, limbs in pairs(limbs) do
            UpdateVisibility(Value) -- Set visibility based on the toggle state
        end
    end,
})










local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer 

-- Define settings table to hold ESP settings
local settings_tbl = {
    ESP_Enabled = false,  -- Set to false by default to ensure it's not enabled initially
    ESP_TeamCheck = false,
    Chams = true,
    Chams_Color = Color3.fromRGB(255, 255, 255),
    Chams_Transparency = 0.1,
    Chams_Glow_Color = Color3.fromRGB(255, 255, 255)
}

-- Create Toggle for Chams
Toggle = Tab:CreateToggle({
    Name = "Chams Esp",
    CurrentValue = false,  -- Set to false to ensure it's disabled initially
    Flag = nil,  -- A unique flag identifier for this toggle
    Callback = function(Value)
        settings_tbl.ESP_Enabled = Value  -- Update the setting based on the toggle
        if not Value then
            -- If the toggle is turned off, destroy all chams on players
            for _, player in next, Players:GetPlayers() do 
                if player ~= LocalPlayer and player.Character then
                    destroy_chams(player.Character)
                end
            end
        end
    end,
})

function destroy_chams(char)
    for _, part in next, char:GetChildren() do 
        if part:IsA("BasePart") and part.Transparency ~= 1 then
            if part:FindFirstChild("Glow") and part:FindFirstChild("Chams") then
                part.Glow:Destroy()
                part.Chams:Destroy() 
            end 
        end 
    end 
end

RunService.Heartbeat:Connect(function()
    if settings_tbl.ESP_Enabled then
        for _, player in next, Players:GetPlayers() do 
            if player ~= LocalPlayer then
                if player.Character and
                   player.Character:FindFirstChild("HumanoidRootPart") and 
                   player.Character:FindFirstChild("Humanoid") and 
                   player.Character:FindFirstChild("Humanoid").Health ~= 0 then

                    if settings_tbl.ESP_TeamCheck == false then
                        local char = player.Character 
                        for _, part in next, char:GetChildren() do 
                            if part:IsA("BasePart") and part.Transparency ~= 1 then
                                if settings_tbl.Chams then
                                    if not part:FindFirstChild("Glow") and not part:FindFirstChild("Chams") then
                                        local chams_box = Instance.new("BoxHandleAdornment", part)
                                        chams_box.Name = "Chams"
                                        chams_box.AlwaysOnTop = true 
                                        chams_box.ZIndex = 4 
                                        chams_box.Adornee = part 
                                        chams_box.Color3 = settings_tbl.Chams_Color
                                        chams_box.Transparency = settings_tbl.Chams_Transparency
                                        chams_box.Size = part.Size + Vector3.new(0.02, 0.02, 0.02)

                                        local glow_box = Instance.new("BoxHandleAdornment", part)
                                        glow_box.Name = "Glow"
                                        glow_box.AlwaysOnTop = false 
                                        glow_box.ZIndex = 3 
                                        glow_box.Adornee = part 
                                        glow_box.Color3 = settings_tbl.Chams_Glow_Color
                                        glow_box.Size = chams_box.Size + Vector3.new(0.13, 0.13, 0.13)
                                    end
                                else
                                    destroy_chams(char)
                                end
                            end
                        end
                    else
                        if player.Team == LocalPlayer.Team then
                            destroy_chams(player.Character)
                        end
                    end
                else
                    destroy_chams(player.Character)
                end
            end
        end
    else 
        for _, player in next, Players:GetPlayers() do 
            if player ~= LocalPlayer and 
               player.Character and 
               player.Character:FindFirstChild("HumanoidRootPart") and 
               player.Character:FindFirstChild("Humanoid") and 
               player.Character:FindFirstChild("Humanoid").Health ~= 0 then
                destroy_chams(player.Character)
            end
        end
    end
end)













local function API_Check()
    if Drawing == nil then
        return "No"
    else
        return "Yes"
    end
end

local Find_Required = API_Check()

if Find_Required == "No" then
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Exunys Developer",
        Text = "Tracer script could not be loaded because your exploit is unsupported.",
        Duration = math.huge,
        Button1 = "OK"
    })

    return
end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = game:GetService("Workspace").CurrentCamera
local UserInputService = game:GetService("UserInputService")
local TestService = game:GetService("TestService")

local Typing = false

_G.SendNotifications = true
_G.DefaultSettings = false
_G.TeamCheck = true
_G.FromMouse = false
_G.FromCenter = false
_G.FromBottom = true
_G.TracersVisible = true
_G.TracerColor = Color3.fromRGB(255, 255, 255)
_G.TracerThickness = 1
_G.TracerTransparency = 0.7
_G.ModeSkipKey = Enum.KeyCode.E
_G.DisableKey = Enum.KeyCode.Q

-- Set TracersEnabled to false by default
local TracersEnabled = false

local function CreateTracers()
    for _, v in next, Players:GetPlayers() do
        if v.Name ~= game.Players.LocalPlayer.Name then
            local TracerLine = Drawing.new("Line")

            RunService.RenderStepped:Connect(function()
                if not TracersEnabled then
                    TracerLine.Visible = false
                    return
                end

                if workspace:FindFirstChild(v.Name) and workspace[v.Name]:FindFirstChild("HumanoidRootPart") then
                    local HumanoidRootPart_Position = workspace[v.Name].HumanoidRootPart.CFrame
                    local Vector, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart_Position.Position + Vector3.new(0, -1, 0))

                    TracerLine.Thickness = _G.TracerThickness
                    TracerLine.Transparency = _G.TracerTransparency
                    TracerLine.Color = _G.TracerColor

                    if _G.FromMouse then
                        TracerLine.From = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                    elseif _G.FromCenter then
                        TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    elseif _G.FromBottom then
                        TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    end

                    if OnScreen then
                        TracerLine.To = Vector2.new(Vector.X, Vector.Y)
                        if _G.TeamCheck and Players.LocalPlayer.Team == v.Team then
                            TracerLine.Visible = false
                        else
                            TracerLine.Visible = _G.TracersVisible
                        end
                    else
                        TracerLine.Visible = false
                    end
                else
                    TracerLine.Visible = false
                end
            end)

            Players.PlayerRemoving:Connect(function()
                TracerLine.Visible = false
            end)
        end
    end

    Players.PlayerAdded:Connect(function(Player)
        Player.CharacterAdded:Connect(function(v)
            if v.Name ~= game.Players.LocalPlayer.Name then
                local TracerLine = Drawing.new("Line")

                RunService.RenderStepped:Connect(function()
                    if not TracersEnabled then
                        TracerLine.Visible = false
                        return
                    end

                    if workspace:FindFirstChild(v.Name) and workspace[v.Name]:FindFirstChild("HumanoidRootPart") then
                        local HumanoidRootPart_Position = workspace[v.Name].HumanoidRootPart.CFrame
                        local Vector, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart_Position.Position + Vector3.new(0, -1, 0))

                        TracerLine.Thickness = _G.TracerThickness
                        TracerLine.Transparency = _G.TracerTransparency
                        TracerLine.Color = _G.TracerColor

                        if _G.FromMouse then
                            TracerLine.From = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        elseif _G.FromCenter then
                            TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        elseif _G.FromBottom then
                            TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                        end

                        if OnScreen then
                            TracerLine.To = Vector2.new(Vector.X, Vector.Y)
                            if _G.TeamCheck and Players.LocalPlayer.Team == Player.Team then
                                TracerLine.Visible = false
                            else
                                TracerLine.Visible = _G.TracersVisible
                            end
                        else
                            TracerLine.Visible = false
                        end
                    else
                        TracerLine.Visible = false
                    end
                end)

                Players.PlayerRemoving:Connect(function()
                    TracerLine.Visible = false
                end)
            end
        end)
    end)
end

UserInputService.TextBoxFocused:Connect(function()
    Typing = true
end)

UserInputService.TextBoxFocusReleased:Connect(function()
    Typing = false
end)

UserInputService.InputBegan:Connect(function(Input)
    if Input.KeyCode == _G.ModeSkipKey and not Typing then
        if _G.FromMouse then
            _G.FromMouse = false
            _G.FromBottom = true
            if _G.SendNotifications then
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "Notification",
                    Text = "Tracers will now come from the bottom of your screen (Mode 1)",
                    Duration = 5,
                })
            end
        elseif _G.FromBottom then
            _G.FromBottom = false
            _G.FromCenter = true
            if _G.SendNotifications then
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "Notification",
                    Text = "Tracers will now come from the center of your screen (Mode 2)",
                    Duration = 5,
                })
            end
        elseif _G.FromCenter then
            _G.FromCenter = false
            _G.FromMouse = true
            if _G.SendNotifications then
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "Notification",
                    Text = "Tracers will now come from the position of your mouse cursor (Mode 3)",
                    Duration = 5,
                })
            end
        end
    elseif Input.KeyCode == _G.DisableKey and not Typing then
        _G.TracersVisible = not _G.TracersVisible
        if _G.SendNotifications then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Notification",
                Text = "The tracers' visibility is now set to " .. tostring(_G.TracersVisible) .. ".",
                Duration = 5,
            })
        end
    end
end)

if _G.DefaultSettings then
    _G.TeamCheck = true
    _G.FromMouse = false
    _G.FromCenter = false
    _G.FromBottom = true
    _G.TracersVisible = true
    _G.TracerColor = Color3.fromRGB(255, 255, 255)
    _G.TracerThickness = 1
    _G.TracerTransparency = 0.5
    _G.ModeSkipKey = Enum.KeyCode.E
    _G.DisableKey = Enum.KeyCode.Q
end

Success, Errored = pcall(function()
    CreateTracers()
end)

if Success and not Errored then
    if _G.SendNotifications then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Notification",
            Text = "Tracer script has successfully loaded.",
            Duration = 5,
        })
    end
elseif Errored and not Success then
    if _G.SendNotifications then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Notification",
            Text = "Tracer script has errored while loading, please check the developer console! (F9)",
            Duration = 5,
        })
    end
    TestService:Message("The tracer script has errored, please notify Exunys with the following information:")
    warn(Errored)
    print("!! IF THE ERROR IS A FALSE POSITIVE (says that a player cannot be found) THEN DO NOT BOTHER !!")
end

-- Example Toggle Integration
Toggle = Tab:CreateToggle({
    Name = "Tracers Esp",
    CurrentValue = false,  -- Set default to false to ensure tracers are off initially
    Flag = nil,  -- A unique flag for configuration saving
    Callback = function(Value)
        TracersEnabled = Value
        if _G.SendNotifications then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Notification",
                Text = "Tracers have been " .. (Value and "enabled" or "disabled") .. ".",
                Duration = 5,
            })
        end
    end,
})




Section = Tab:CreateSection("In Game Esp")





local esp_data = {} 
local espTilesName = 'nigger'

local function createESP(parent, label)
    local BillboardGui = Instance.new('BillboardGui')
    local TextLabel = Instance.new('TextLabel')

    BillboardGui.Name = espTilesName
    BillboardGui.Parent = parent
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = UDim2.new(0, 50, 0, 50)
    BillboardGui.StudsOffset = Vector3.new(0, 2, 0)

    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.Text = label
    TextLabel.TextColor3 = Color3.new(255, 255, 255)
    TextLabel.TextScaled = false

    return BillboardGui
end

local function applyESP(object, label)
    if object:IsA('TouchTransmitter') then
        local parent = object.Parent
        if not parent:FindFirstChild(espTilesName) then
            local newESP = createESP(parent, label)
            esp_data[parent] = newESP
        end
    end
end

local function toggleESP(enable, name, label)
    if enable then
        for _, v in ipairs(game.Workspace:GetDescendants()) do
            if v:IsA('TouchTransmitter') and v.Parent.Name == name then
                applyESP(v, label)
            end
        end
        
        game.Workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA('TouchTransmitter') and descendant.Parent.Name == name then
                applyESP(descendant, label)
            end
        end)
    else
        for parent, espElement in pairs(esp_data) do
            if parent and espElement then
                espElement:Destroy()
                esp_data[parent] = nil
            end
        end
    end
end

-- Create toggles for ESP
Toggle = Tab:CreateToggle({
    Name = "Ammo Box ESP",
    CurrentValue = false,
    Flag = nil, -- Unique identifier for configuration
    Callback = function(enabled)
        toggleESP(enabled, 'DeadAmmo', 'Ammo Box')
    end,
})

Toggle = Tab:CreateToggle({
    Name = "HP Jar Esp",
    CurrentValue = false,
    Flag = nil, -- Unique identifier for configuration
    Callback = function(enabled)
        toggleESP(enabled, 'DeadHP', 'HP Jar')
    end,
})










Tab = Window:CreateTab("Aimbot", 4483362458) -- Title, Image




-- Services
Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer
Camera = workspace.CurrentCamera
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")

-- Settings
aimbotEnabled = false
fovCircleVisible = false
teamCheck = true
fov = 80
smoothing = 1
fovColor = Color3.fromRGB(0, 0, 255)

-- FOV Circle Drawing
local FOVring = Drawing.new("Circle")
FOVring.Visible = false
FOVring.Thickness = 1.5
FOVring.Radius = fov
FOVring.Transparency = 1
FOVring.Color = fovColor
FOVring.Position = Camera.ViewportSize / 2

-- Function to get the closest player
local function getClosest(cframe)
    local ray = Ray.new(cframe.Position, cframe.LookVector).Unit
    local target = nil
    local mag = math.huge

    for _, v in pairs(Players:GetPlayers()) do
        if v.Character and v.Character:FindFirstChild("Head") and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v ~= LocalPlayer and (v.Team ~= LocalPlayer.Team or not teamCheck) then
            local magBuf = (v.Character.Head.Position - ray:ClosestPoint(v.Character.Head.Position)).Magnitude
            if magBuf < mag then
                mag = magBuf
                target = v
            end
        end
    end

    return target
end

Section = Tab:CreateSection("Aimbot Settings")


-- Create the toggle UI element for aimbot
AimbotToggle = Tab:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = nil,
    Callback = function(Value)
        aimbotEnabled = Value
    end,
})

Toggle = Tab:CreateToggle({
    Name = "Team Check",
    CurrentValue = teamCheck,
    Flag = nil,
    Callback = function(Value)
        teamCheck = Value
    end,
})



local Section = Tab:CreateSection("TriggerBot")




local function AWXGJ_fake_script() -- TriggerBot.LocalScript 
    local script = Instance.new('LocalScript', TriggerBot)

    getfenv().script = Instance.new('Script', TriggerBot)

    -- Create the toggle for enabling/disabling the triggerbot
    local TriggerBotToggle = false -- Initialize the triggerbot toggle state
    Tab:CreateToggle({
        Name = "TriggerBot",
        CurrentValue = false,
        Flag = nil, -- Unique flag for configuration
        Callback = function(Value)
            TriggerBotToggle = Value -- Update the toggle variable based on the toggle's state
        end,
    })

    -- Create the toggle for enabling/disabling team check
    local TeamCheckToggle = false -- Initialize the team check toggle state
    Tab:CreateToggle({
        Name = "Team Check",
        CurrentValue = false,
        Flag = nil, -- Unique flag for configuration
        Callback = function(Value)
            TeamCheckToggle = Value -- Update the team check toggle state
        end,
    })

    local HoldClick = true
    local Players = game:GetService('Players')
    local RunService = game:GetService('RunService')
    local LocalPlayer = Players.LocalPlayer
    local Mouse = LocalPlayer:GetMouse()
    local CurrentlyPressed = false

    RunService.RenderStepped:Connect(function()
        if TriggerBotToggle then
            if Mouse.Target then
                local targetPlayer = Players:GetPlayerFromCharacter(Mouse.Target.Parent)
                local targetHumanoid = Mouse.Target.Parent:FindFirstChild('Humanoid')

                if targetHumanoid then
                    local isOpponent = true
                    
                    -- Check if team check is enabled and if the target is on the same team
                    if TeamCheckToggle and targetPlayer then
                        isOpponent = LocalPlayer.Team ~= targetPlayer.Team
                    end

                    if isOpponent then
                        if HoldClick then
                            if not CurrentlyPressed then
                                CurrentlyPressed = true
                                mouse1press() -- Hold the mouse button down
                            end
                        else
                            mouse1click() -- Click once
                        end
                    end
                else
                    if HoldClick and CurrentlyPressed then
                        CurrentlyPressed = false
                        mouse1release() -- Release the mouse button if not targeting a humanoid
                    end
                end
            elseif HoldClick and CurrentlyPressed then
                CurrentlyPressed = false
                mouse1release() -- Release if the target is not valid
            end
        end
    end)
end
coroutine.wrap(AWXGJ_fake_script)()










Section = Tab:CreateSection("FOV")


-- Create the toggle UI element for FOV circle visibility
FOVToggle = Tab:CreateToggle({
    Name = "Draw FOV",
    CurrentValue = false,
    Flag = nil,
    Callback = function(Value)
        fovCircleVisible = Value
        FOVring.Visible = fovCircleVisible
    end,
})



-- Create the FOV slider UI element
Slider = Tab:CreateSlider({
    Name = "FOV Radius",
    Range = {0, 300},
    Increment = 5,
    Suffix = "Studs",
    CurrentValue = fov,
    Flag = nil,
    Callback = function(Value)
        fov = Value
        FOVring.Radius = fov
    end,
})

-- Create the color picker UI element
ColorPicker = Tab:CreateColorPicker({
    Name = "FOV color",
    Color = fovColor,
    Flag = nil,
    Callback = function(Value)
        fovColor = Value
        FOVring.Color = fovColor
    end,
})



-- Main loop
local loop
loop = RunService.RenderStepped:Connect(function()
    local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
    local cam = Camera
    local zz = cam.ViewportSize / 2

    if aimbotEnabled then
        if pressed then
            local curTar = getClosest(cam.CFrame)
            if curTar and curTar.Character and curTar.Character:FindFirstChild("Head") then
                local ssHeadPoint = cam:WorldToScreenPoint(curTar.Character.Head.Position)
                ssHeadPoint = Vector2.new(ssHeadPoint.X, ssHeadPoint.Y)
                if (ssHeadPoint - zz).Magnitude < fov then
                    cam.CFrame = cam.CFrame:Lerp(CFrame.new(cam.CFrame.Position, curTar.Character.Head.Position), smoothing)
                end
            end
        end
    end

    if UserInputService:IsKeyDown(Enum.KeyCode.Delete) then
        loop:Disconnect()
        FOVring:Remove()
    end
end)







Section = Tab:CreateSection("CrossHair")





local function safeCall(func)
    local success, err = pcall(func)
    if not success then
        warn("Error: " .. err)
    end
end

safeCall(function()
    getgenv().Crosshair.Functions:Exit()
end)

getgenv().Crosshair = {}
local env = getgenv().Crosshair

local Services = {
    StarterGui = game:GetService("StarterGui"),
    RunService = game:GetService("RunService"),
    HttpService = game:GetService("HttpService"),
    UserInputService = game:GetService("UserInputService"),
    Camera = game:GetService("Workspace").CurrentCamera
}

local Title = "Exunys Developer"
local FileNames = {"Crosshair", "Configuration.json", "Crosshair.json"}
local AxisX, AxisY
local AxisConnection, CrosshairConnection

env.Settings = {
    SendNotifications = false,
    SaveSettings = true,
    ReloadOnTeleport = true,
    Enabled = false,
    ToMouse = true
}

env.CrosshairSettings = {
    Size = 12,
    Thickness = 1,
    Color = "255, 0, 0",
    Transparency = 1,
    GapSize = 5,
    CenterDot = false,
    CenterDotColor = "255, 0, 0",
    CenterDotSize = 1,
    CenterDotTransparency = 1,
    CenterDotFilled = true
}

env.Construction = {
    LeftLine = Drawing.new("Line"),
    RightLine = Drawing.new("Line"),
    TopLine = Drawing.new("Line"),
    BottomLine = Drawing.new("Line"),
    CenterDot = Drawing.new("Circle")
}

local function Encode(tbl)
    return tbl and Services.HttpService:JSONEncode(tbl) or nil
end

local function Decode(str)
    return str and Services.HttpService:JSONDecode(str) or nil
end

local function GetColor(colorStr)
    local R, G, B = string.match(colorStr, "(%d+),%s*(%d+),%s*(%d+)")
    return Color3.fromRGB(tonumber(R), tonumber(G), tonumber(B))
end

local function Load()
    AxisConnection = Services.RunService.RenderStepped:Connect(function()
        AxisX, AxisY = env.Settings.ToMouse and Services.UserInputService:GetMouseLocation().X or Services.Camera.ViewportSize.X / 2,
                       env.Settings.ToMouse and Services.UserInputService:GetMouseLocation().Y or Services.Camera.ViewportSize.Y / 2
    end)

    CrosshairConnection = Services.RunService.RenderStepped:Connect(function()
        local enabled = env.Settings.Enabled
        local color = GetColor(env.CrosshairSettings.Color)
        local thickness = env.CrosshairSettings.Thickness
        local transparency = env.CrosshairSettings.Transparency
        local gap = env.CrosshairSettings.GapSize
        local size = env.CrosshairSettings.Size

        -- Update lines
        for _, line in pairs({"LeftLine", "RightLine", "TopLine", "BottomLine"}) do
            env.Construction[line].Visible = enabled
            env.Construction[line].Color = color
            env.Construction[line].Thickness = thickness
            env.Construction[line].Transparency = transparency
        end

        -- Set positions
        env.Construction.LeftLine.From = Vector2.new(AxisX + gap, AxisY)
        env.Construction.LeftLine.To = Vector2.new(AxisX + size, AxisY)
        env.Construction.RightLine.From = Vector2.new(AxisX - gap, AxisY)
        env.Construction.RightLine.To = Vector2.new(AxisX - size, AxisY)
        env.Construction.TopLine.From = Vector2.new(AxisX, AxisY + gap)
        env.Construction.TopLine.To = Vector2.new(AxisX, AxisY + size)
        env.Construction.BottomLine.From = Vector2.new(AxisX, AxisY - gap)
        env.Construction.BottomLine.To = Vector2.new(AxisX, AxisY - size)

        -- Update center dot
        local centerDot = env.Construction.CenterDot
        centerDot.Visible = enabled and env.CrosshairSettings.CenterDot
        centerDot.Color = GetColor(env.CrosshairSettings.CenterDotColor)
        centerDot.Radius = env.CrosshairSettings.CenterDotSize
        centerDot.Transparency = env.CrosshairSettings.CenterDotTransparency
        centerDot.Filled = env.CrosshairSettings.CenterDotFilled
        centerDot.Position = Vector2.new(AxisX, AxisY)
    end)
end

local function SaveSettings()
    if env.Settings.SaveSettings then
        local folderPath = Title.."/"..FileNames[1]
        if not isfolder(Title) then makefolder(Title) end
        if not isfolder(folderPath) then makefolder(folderPath) end
        
        writefile(folderPath.."/"..FileNames[2], Encode(env.Settings))
        writefile(folderPath.."/"..FileNames[3], Encode(env.CrosshairSettings))
    end
end

if env.Settings.SaveSettings then
    if isfile(Title.."/"..FileNames[1].."/"..FileNames[2]) then
        env.Settings = Decode(readfile(Title.."/"..FileNames[1].."/"..FileNames[2]))
    end
    if isfile(Title.."/"..FileNames[1].."/"..FileNames[3]) then
        env.CrosshairSettings = Decode(readfile(Title.."/"..FileNames[1].."/"..FileNames[3]))
    end
    coroutine.wrap(function()
        while wait(10) do
            SaveSettings()
        end
    end)()
else
    if isfolder(Title) then
        delfolder(Title)
    end
end

if env.Settings.ReloadOnTeleport and syn and syn.queue_on_teleport then
    syn.queue_on_teleport(game:HttpGet("https://pastebin.com/raw/4L7an7MY"))
end

env.Functions = {}

function env.Functions:Exit()
    for _, value in pairs(env.Construction) do
        value:Remove()
    end
    AxisConnection:Disconnect()
    CrosshairConnection:Disconnect()
    getgenv().Crosshair = nil
end

function env.Functions:Restart()
    for _, value in pairs(env.Construction) do
        value:Remove()
    end
    AxisConnection:Disconnect()
    CrosshairConnection:Disconnect()
    Load()
end

function env.Functions:ResetSettings()
    env.Settings = {
        SendNotifications = false,
        SaveSettings = true,
        ReloadOnTeleport = true,
        Enabled = false,
        ToMouse = true
    }

    env.CrosshairSettings = {
        Size = 12,
        Thickness = 1,
        Color = "255, 0, 0",
        Transparency = 1,
        GapSize = 5,
        CenterDot = false,
        CenterDotColor = "255, 0, 0",
        CenterDotSize = 1,
        CenterDotTransparency = 1,
        CenterDotFilled = true
    }

    SaveSettings()
end

function env.Functions:SetMouseIcon(value)
    UserInputService.MouseIconEnabled = value ~= nil and value or true
end

function env.Functions:GetDocumentation()
    setclipboard("https://github.com/Exunys/Crosshair-V2")
end

if not Drawing or not writefile or not makefolder then
    return
end

Toggle = Tab:CreateToggle({
    Name = "Enable Crosshair",
    CurrentValue = false,
    Flag = nil,
    Callback = function(value)
        env.Settings.Enabled = value
    end,
})

ColorPicker = Tab:CreateColorPicker({
    Name = "Pick a Color",
    Color = Color3.fromRGB(255, 0, 0),
    Flag = nil,
    Callback = function(value)
        local r, g, b = value.R * 255, value.G * 255, value.B * 255
        env.CrosshairSettings.Color = string.format("%d, %d, %d", r, g, b)
        env.CrosshairSettings.CenterDotColor = string.format("%d, %d, %d", r, g, b)
    end,
})

Load()








Tab = Window:CreateTab("Settings", 4483362458) -- Title, Image



Section = Tab:CreateSection("Performance")

-- Stores original materials, textures, and lighting/terrain settings
local originalMaterials = {}
local originalDecalsTextures = {}
local originalLightingSettings = {
    GlobalShadows = game.Lighting.GlobalShadows,
    FogEnd = game.Lighting.FogEnd,
    Brightness = game.Lighting.Brightness
}
local originalTerrainSettings = {
    WaterWaveSize = game.Workspace.Terrain.WaterWaveSize,
    WaterWaveSpeed = game.Workspace.Terrain.WaterWaveSpeed,
    WaterReflectance = game.Workspace.Terrain.WaterReflectance,
    WaterTransparency = game.Workspace.Terrain.WaterTransparency
}
local originalEffects = {}

-- Anti Lag Toggle
Toggle = Tab:CreateToggle({
    Name = "Anti Lag",
    CurrentValue = false,
    Flag = nil,
    Callback = function(state)
        if state then
            for ai, O in pairs(game:GetService("Workspace"):GetDescendants()) do
                if O:IsA("BasePart") and not O.Parent:FindFirstChild("Humanoid") then
                    originalMaterials[O] = O.Material
                    O.Material = Enum.Material.SmoothPlastic
                    if O:IsA("Texture") then
                        table.insert(originalDecalsTextures, O)
                        O:Destroy()
                    end
                end
            end
        else
            for O, material in pairs(originalMaterials) do
                if O and O:IsA("BasePart") then
                    O.Material = material
                end
            end
            originalMaterials = {}
        end
    end
})

-- FPS Boost Toggle
Toggle = Tab:CreateToggle({
    Name = "FPS Boost",
    CurrentValue = false,
    Flag = nil,
    Callback = function(state)
        if state then
            local g = game
            local w = g.Workspace
            local l = g.Lighting
            local t = w.Terrain

            -- Adjusting terrain and lighting
            t.WaterWaveSize = 0
            t.WaterWaveSpeed = 0
            t.WaterReflectance = 0
            t.WaterTransparency = 0
            l.GlobalShadows = false
            l.FogEnd = 9e9
            l.Brightness = 0
            settings().Rendering.QualityLevel = "Level01"

            -- Optimizing parts, textures, and effects
            for _, v in pairs(g:GetDescendants()) do
                if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
                    originalMaterials[v] = v.Material
                    v.Material = "Plastic"
                    v.Reflectance = 0
                elseif v:IsA("Decal") or v:IsA("Texture") then
                    table.insert(originalDecalsTextures, v)
                    v.Transparency = 1
                elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                    v.Lifetime = NumberRange.new(0)
                elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
                    v.Enabled = false
                end
            end

            -- Disable lighting effects
            for _, e in pairs(l:GetChildren()) do
                if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
                    originalEffects[e] = e.Enabled
                    e.Enabled = false
                end
            end
        else
            local t = game.Workspace.Terrain
            t.WaterWaveSize = originalTerrainSettings.WaterWaveSize
            t.WaterWaveSpeed = originalTerrainSettings.WaterWaveSpeed
            t.WaterReflectance = originalTerrainSettings.WaterReflectance
            t.WaterTransparency = originalTerrainSettings.WaterTransparency

            game.Lighting.GlobalShadows = originalLightingSettings.GlobalShadows
            game.Lighting.FogEnd = originalLightingSettings.FogEnd
            game.Lighting.Brightness = originalLightingSettings.Brightness

            settings().Rendering.QualityLevel = "Automatic"

            for v, material in pairs(originalMaterials) do
                if v and v:IsA("BasePart") then
                    v.Material = material
                    v.Reflectance = 0
                end
            end
            originalMaterials = {}

            for e, enabled in pairs(originalEffects) do
                if e then
                    e.Enabled = enabled
                end
            end
            originalEffects = {}

            for _, v in pairs(originalDecalsTextures) do
                if v and v.Parent then
                    v.Transparency = 0
                end
            end
            originalDecalsTextures = {}
        end
    end
})

-- Full Bright Toggle
Toggle = Tab:CreateToggle({
    Name = "Full Bright",
    CurrentValue = false,
    Flag = nil,
    Callback = function(enabled)
        fullBrightEnabled = enabled
        local Light = game:GetService("Lighting")

        local function doFullBright()
            if fullBrightEnabled then
                Light.Ambient = Color3.new(1, 1, 1)
                Light.ColorShift_Bottom = Color3.new(1, 1, 1)
                Light.ColorShift_Top = Color3.new(1, 1, 1)
            else
                Light.Ambient = Color3.new(0.5, 0.5, 0.5)
                Light.ColorShift_Bottom = Color3.new(0, 0, 0)
                Light.ColorShift_Top = Color3.new(0, 0, 0)
            end
        end

        doFullBright()
        Light.LightingChanged:Connect(doFullBright)
    end
})









local Button = Tab:CreateButton({
   Name = "Destroy UI",
   Callback = function()
           Rayfield:Destroy()
   end,
})




Section = Tab:CreateSection("Credits")

Label = Tab:CreateLabel("By They_fwdan")





Button = Tab:CreateButton({
   Name = "Join The Discord!",
   Callback = function()
     setclipboard("https://discord.gg/qHPtkS5jr3")

            Rayfield:Notify({
   Title = "Copied!",
   Content = "The discord link has been copied to your clipboard!",
   Duration = 6.5,
   Image = 4483362458,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "Okay!",
         Callback = function()
         print("The user tapped Okay!")
      end
   },
},
})
   end,
})


